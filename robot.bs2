' {$STAMP BS2}
' {$PBASIC 2.5}

Kpl           CON -35
Kpr           CON 35
SetPoint      CON 1
CenterPulse   CON 750
threshold     CON 7
stepInc       CON 10

mineColor     CON 50

fBackwardL    CON 650
fForwardR     CON 650
fBackwardR    CON 850
fForwardL     CON 850
still	         CON 750

photoLeft     PIN 15
photoRight    PIN 14
irLeft        PIN 11
irRight       PIN 10
leftWheel     PIN 13
rightWheel    PIN 12
LEDLeft       PIN 9
LEDRight      PIN 8
LED4          PIN 6
LED3          PIN 4
LED2          PIN 3
LED1          PIN 2
speaker       PIN 5
'whiskerLeft   PIN 2
'whiskerRight  PIN 3
irLEDLeft     PIN 1
irLEDRight    PIN 0

freqSelect    VAR NIB
irFrequency   VAR WORD
distanceLeft  VAR NIB
distanceRight VAR NIB
pulseLeft     VAR WORD
pulseRight    VAR WORD
counter       VAR WORD
timeLeft      VAR BYTE
timeRight     VAR BYTE
lastTimeLeft  VAR BYTE
lastTimeRight VAR BYTE
dTimeL        VAR BYTE
dTimeR        VAR BYTE
negDeltaRight VAR BIT
negDeltaLeft  VAR BIT

irDetectLeft  VAR BIT 'state variable
irDetectRight VAR BIT 'state variable
odd           VAR BIT 'state variabel
forwardMode   VAR BIT 'state variable
onMineL       VAR BIT 'state variable
onMineR	    VAR BIT 'state variable
avoidMode     VAR BIT 'state variable
turnMode      VAR BIT 'state variable
updateRandom  VAR BIT 'state variable


result        VAR BYTE
i             VAR WORD
j             VAR WORD
k             VAR BIT
nPulses       VAR WORD

'''''''''''''''
'Program start'
'''''''''''''''

''''''
'Init'
''''''
forwardMode   = 1
onMineR 	    = 0 
onMineL 	    = 0 
avoidMode     = 0 
irDetectLeft  = 0
irDetectRight = 0    
odd           = 0
updateRandom  = 1
result = 0

LOW LEDLeft
LOW LEDRight
dTimeL = 0
dTimeR = 0
lastTimeLeft = 0
lastTimeRight = 0
i = 0
j = 0
k = 0

LOW LED1
LOW LED2
LOW LED3
LOW LED4

HIGH photoLeft
PAUSE 2
RCTIME photoLeft,1,timeLeft
lastTimeLeft = timeLeft
HIGH photoRight
PAUSE 2
RCTIME photoRight,1,timeRight
lastTimeRight = timeRight

'''''''''''''''
'The main loop'
'''''''''''''''
' Alternate between turning and moving  forward a random length unit
DO
  IF updateRandom = 1 THEN 
    result = result + timeLeft
    RANDOM result
    'DEBUG DEC5 result
    result = result / 6 + 10' MAGIC NUMBERS FTW
    updateRandom = 0
    'DEBUG DEC5 result
  ENDIF	

  'Always detect mines
  GOSUB Detect_Mines
  GOSUB Get_Ir_Distances

  IF onMineL = 1 THEN 
    HIGH LEDLeft 
  ELSE
    LOW LEDLeft 
  ENDIF 
  
  IF onMineR = 1 THEN
    HIGH LEDRight 
  ELSE 
    LOW LEDRight 
  ENDIF

  IF onMineL = 1 OR onMineR = 1 OR avoidMode = 1 THEN
    IF avoidMode = 0 THEN
      IF j > 25 THEN 
        GOSUB Mine_Melody
      ENDIF
      j = 0
    ENDIF
    GOSUB Turn_Random
    avoidMode = 1
    forwardMode = 0
    turnMode = 0
  ENDIF

  IF avoidMode = 1 AND onMineL = 0 AND onMineR = 0 AND irDetectLeft = 0 AND irDetectRight = 0 THEN
  	avoidMode = 0
     forwardMode = 1
     turnMode = 0
     'Get safe
  ENDIF

  IF forwardMode = 1 THEN ' Move forward, avoid walls and look for mines
    'pulseLeft = (SetPoint - distanceRight) * Kpl + CenterPulse
    'pulseRight = (SetPoint - distanceLeft) * Kpr + CenterPulse
    IF irDetectRight = 1 THEN
      pulseRight = fForwardR
      pulseLeft = fBackwardL
      IF k = 1 THEN
        result = 40
        turnMode = 1
        forwardMode = 0
        i = 0
      ENDIF
      k = 0
    ELSEIF irDetectLeft = 1 THEN
      pulseRight = fBackwardR
      pulseLeft = fForwardL
      k = 1
    ELSE
      pulseRight = fForwardR
      pulseLeft = fForwardL
    ENDIF
    GOSUB Send_Pulse

    'Exit move forward state
    IF i > (result) THEN
      forwardMode = 0
      turnMode = 1
      i = 0
      updateRandom = 1
    ENDIF
  ELSEIF turnMode = 1 AND j > 40 THEN ' Turn and look for mines
    GOSUB Turn_Robot

    'Exit turn state
    IF i > result OR irDetectLeft = 1 OR irDetectRight = 1 THEN
      forwardMode = 1
      turnMode = 0
      i = 0
	 updateRandom = 1
    ENDIF
  ELSEIF turnMode = 1 AND j <= 40 THEN
    turnMode = 0
    forwardMode = 1
  ENDIF
	
  odd = ~odd 
  i = i + 1
  j = j + 1
  GOSUB Funny_Lights
LOOP

''
'Functi
'
Detect_Mines:
  HIGH photoLeft
  PAUSE 2
  RCTIME photoLeft,1,timeLeft

  HIGH photoRight
  PAUSE 2
  RCTIME photoRight,1,timeRight

  'DEBUG "Left: ", DEC5 timeleft, ", Right: ", DEC5 timeRight, CR
  'DEBUG "dTimeL: ", DEC5 dTimeL, ", dTimeR: ", DEC5 dTimeR,CR

  dTimeL = timeLeft-lastTimeLeft
  dTimeR = timeRight-lastTimeRight
  negDeltaLeft = (dTimeL & %10000000)>>7
  negDeltaRight = (dTimeR & %10000000)>>7


  IF timeRight < mineColor THEN 
    onMineR = 0 
  ELSEIF timeRight > mineColor+10 THEN
    onMineR = 1
  ENDIF
  IF timeLeft < mineColor THEN 
    onMineL = 0 
  ELSEIF timeLeft > mineColor+10 THEN 
    onMineL = 1
  ENDIF 

  IF negDeltaLeft = 1 OR negDeltaRight = 1 THEN
    ' Left sensor went off mine
    IF (dTimeL <= 255-threshold) AND negDeltaLeft = 1 THEN 
      onMineL = 0 
    ENDIF
    ' Right sensor went off mine
    IF (dTimeR <= 255-threshold) AND negDeltaRight = 1 THEN 
      onMineR = 0 
    ENDIF
  ENDIF

  'Mine found under both sensors
  IF (dTimeL >= threshold) AND negDeltaLeft = 0 THEN 
    onMineL = 1
  'Mine found under right sensor
  ELSEIF (dTimeR >= threshold) AND negDeltaRight = 0 THEN 
    onMineR = 1
  ENDIF

  IF odd = 1 THEN
    lastTimeLeft = timeLeft
    lastTimeRight = timeRight
  ENDIF

  RETURN

Turn_Random:
  IF avoidMode = 0 THEN
    IF (result & 1) = 1  THEN
      pulseLeft = fBackwardL
      pulseRight = still
    ELSE
      pulseLeft = still
      pulseRight = fBackwardR
    ENDIF
  ENDIF
  GOSUB Send_Pulse
  RETURN

Get_Ir_Distances:
  distanceLeft = 0
  distanceRight = 0
  FOR freqSelect = 0 TO 4
      LOOKUP freqSelect,[41500,42250,42000,42250,42500], irFrequency

      FREQOUT irLEDLeft,1,irFrequency
      'irDetectLeft = irLeft
      distanceLeft = distanceLeft + irLeft

      FREQOUT irLEDRight,1,irFrequency
      'irDetectRight = irRight
      distanceRight = distanceRight + irRight
  NEXT
  IF distanceLeft < 5 THEN
	irDetectLeft = 1
  ELSE 
	irDetectLeft = 0
  ENDIF
  IF distanceRight < 5 THEN
	irDetectRight = 1
  ELSE 
     irDetectRight = 0
  ENDIF
  RETURN

Send_Pulse:
  PULSOUT leftWheel,pulseLeft
  PULSOUT rightWheel,pulseRight
  RETURN

Turn_Robot:
  ' L = 850. R = 650 <-- rakt fram
  IF (result & 1) = 1  THEN
    pulseLeft = still
    pulseRight = fForwardR
  ELSE
    pulseLeft = fForwardL
    pulseRight = still
  ENDIF

  GOSUB Send_Pulse

  RETURN

Mine_Melody:

  FOR freqSelect = 0 TO 9
    IF (freqSelect//2) = 0 THEN
      LOW LED1
      LOW LED2
      LOW LED3
      LOW LED4
    ENDIF
    LOOKUP freqSelect, [9000,8000,7000,6000,5000,4000,3000,2000,1000,1000], irFrequency
    FREQOUT speaker, 50, irFrequency
    PAUSE 5
    IF (freqSelect//2) = 0 THEN
      HIGH LED1
      HIGH LED2
      HIGH LED3
      HIGH LED4
    ENDIF
  NEXT
  RETURN

Funny_Lights:
  IF i//4 = 0 THEN 
    HIGH LED1
    LOW LED4
  ELSEIF i//4 = 1 THEN
    HIGH LED2
    LOW LED1
  ELSEIF i//4 = 2 THEN
    HIGH LED3
    LOW LED2
  ELSEIF i//4 = 3 THEN
   HIGH LED4
   LOW LED3
  ENDIF
RETURN

'Check_Whiskers:
'  IF (whiskerLeft = 0) THEN
'     HIGH LEDLeft
'     DEBUG "LEFT"
'     GOSUB Mine_Melody
'  ELSE
'     LOW LEDLeft
'  ENDIF
'
'  IF (whiskerRight = 0) THEN
'     HIGH LEDRight
'     DEBUG "RIGHT"
'     GOSUB Mine_Melody
'  ELSE
'     LOW LEDRight
'  ENDIF
'  RETURN